
---

# Lumin

Lumin is a statically-typed, high-level programming language designed for simplicity and expressiveness.

---

## Features

* **Primitive types**: `int`, `bool`, `string`
* **User-defined structs**
* **Functions** (`fin`) with typed parameters and return values
* **Control flow**: `if`, `else`, `while`, `for`, `return`
* **Arrays & multi-dimensional arrays**
* **Operators**: arithmetic, comparison, logical, and bitwise
* **Self-referencing updates** via `@`
* **File compilation** to `.lmp` “lumped” intermediate format
* **Range-based literals**: Easily define sequences in arrays using `..`

---

## Installation

Build using CMake:

```bash
git clone https://github.com/liwybloc/Lumin.git
cd Lumin
mkdir build
cd build
cmake ..
make
```

This produces the `lumin` executable.

---

## Usage

### Running Lumin source files

```bash
./lumin [options] <file>
```

Options:

* `--lmp` — Compile `.lum` source to `.lmp` lumped file
* `--run` — Execute a `.lum` or `.lmp` file

Example:

```bash
./lumin --run example.lum
./lumin --lmp example.lum
./lumin --run example.lmp
```

### Source File Extensions

* `.lum` — Lumin source code
* `.lmp` — Lumped intermediate file generated by the Lumper

---

## Language Syntax

### Variables

```lum
int x = 5;
bool flag = true;
string name = "Lumin";
```

### Arrays

```lum
int[] numbers = [1, 2, 3];
int[5] fixedArray; // sized array declaration
```

### Structs

```lum
struct Point {
    int x;
    int y;
};

Point p = { x: 10, y: 20 };
```

### Functions

```lum
fin add(a, b) -> int {
    return a + b;
}
```

### Control Flow

```lum
if (x > 0) {
    x--;
} else {
    x++;
}

while (x < 10) {
    x++;
}

for (int i = 0; i < 10; i++) {
    println(i);
}

return x;
```

### Operators

* Arithmetic: `+`, `-`, `*`, `/`, `%`
* Bitwise: `&`, `|`, `^`, `~`
* Logical: `&&`, `||`, `!`
* Comparison: `==`, `<`, `>`, `<=`, `>=`
* Range: `..` (used in arrays and loops)

---

### Special Features

* **Self-referencing (`@`)**: Allows modifying an element or variable relative to its previous value. Useful in loops or array operations.
* **Defining multiple array values in 1 line (array[1,2] = 5, array[1,2] = [5,6])**: Easily setting values, alongside using ranges 1..5 to set between values. Self-referencing can be used in the indices and values.
* **Easy multidimensional flattening helpers (array{x, y, z})**: Allows you to set an array of any dimensions with element size, e.g. pixels{3, 100, 100} = [255, 0, 0]; will create a 100x100 3-sized array of 255,0,0

---

## Project Structure

```
Lumin/
├── include/          # Header files
├── src/              # Source files
│   ├── main.cpp      # CLI entry point
│   ├── exec/         # Execution engine
│   ├── lumper/       # AST to lumped file
│   └── reader/       # Parser implementation
├── lum/              # Editor/IDE syntax integration
└── test/             # Sample Lumin programs
```

### Components

* **Lexer**: Converts source code into tokens, handles operators, keywords, and literals.
* **Parser**: Builds an AST from tokens, supports expressions, declarations, structs, functions, and control flow.
* **Lumper**: Serializes AST into `.lmp` for faster execution and to work on multiple platforms.
* **Executor**: Interprets AST or lumped files, handles evaluation of expressions, function calls, loops, arrays, and assignments.

---

## Examples

**Hello World**

```lum
fin main() -> nil {
    println("Hello, World!");
}
```

**Array and Loop**

```lum
int[] nums = [1, 2, 3, 4, 5];
for (int i = 0; i < 5; i++) {
    print(nums[i]);
}
println();
```

**Struct Usage**

```lum
struct Point {
    int x;
    int y;
    string z;
};

Point p = { x: 5, y: 10, z: "Hello" };
Point p2 = { 6, 7, "Bye" };
p.x += 2;
println(p.x); // 7
```

**Syntax Sugar Usage**

```lum
string myLongVariable = "Word";
// no repeating variable name, just @
myLongVariable = @ == "Word" ? @ + " Hello" : @ + " Bye";
```
```lum
int[3*100*100] pixels;
// no for loops, sets a 100x100 with 3 sized elements
pixels{3, 100, 100} = [255, 0, 0];
// this will produce [255,0,0,255,0,0,....] for all 100x100
// @ can be used too, and it's element indexed rather than absolute
pixels{3, 100, 100} = @ % 255;
// [0,0,0,1,1,1,2,2,2,....]

// or calling functions with it!
pixels{3, 100, 100} = getRGB(@);

printf("{}\n", pixels[0]);
```

---

## License

This project is licensed under the MIT License. See `LICENSE` for details.

---